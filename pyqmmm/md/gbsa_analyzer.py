"""Process and analyze output from AMBER GBSA calculation"""

import glob
import pandas as pd
import matplotlib.pyplot as plt
from pandas.api.types import CategoricalDtype


def get_gbsa_df(raw) -> pd.DataFrame:
    """
    Turn the GBSA file into a parsable pd.DataFrame.

    Parameters
    ----------
    raw: str
        The name of the GBSA output file.

    Returns
    -------
    df: pd.DataFrame
        The raw GBSA file as a pd.DataFrame

    """

    # List of file keywords from the GBSA output
    total_energy_keyword = "D,E,L,T,A,S,:"
    sidechain_keyword = "S,i,d,e,c,h,a,i,n, ,E,n,e,r,g,y, ,D,e,c,o,m,p,o,s,i,t,i,o,n,:"
    columns = [
        "Resname 1",
        "Resid 1",
        "Resname 2",
        "Resid 2",
        "Internal",
        "Internal SD",
        "Internal SDM",
        "VDW",
        "VDW SD",
        "VDW SDM",
        "Electrostatic",
        "Electrostatic SD",
        "Electrostatic SDM",
        "Polar",
        "Polar SD",
        "Polar SDM",
        "Non-polar",
        "Non-polar SD",
        "Non-polar SDM",
        "Total",
        "Total SD",
        "Total SDM",
    ]
    csv_file_name = "deltas.csv"

    # MMGBSA.py generates four files and we want the one that ends in 24.dat
    delta_section = False
    # The raw file contains data we don't need; we only want the DELTA section
    with open(raw, "r") as raw_data:
        with open(csv_file_name, "w") as csv_file:
            for line in raw_data:
                # If we reach the DELTA section write the current line to a new file
                if delta_section == True:
                    if "T,o,t,a,l" in line:
                        continue
                    if "Std" in line:
                        continue
                    if "Resid" in line:
                        csv_file.write(",".join(columns))
                        continue
                    # Stop at the end of the section
                    if sidechain_keyword in line:
                        break
                    # Save the data to a csv file for to open in pandas later
                    else:
                        line = "\n" + ",".join(line.split())
                        csv_file.write(line)

                # Set a flag when we find the poorly named section generated by GBSA
                if line[: len(total_energy_keyword)] == total_energy_keyword:
                    delta_section = True

    # Save the data to a Pandas dataframe and return the data
    df = pd.read_csv(csv_file_name)
    # Remove all rows where Resid 1 and Resid 2 are the same number
    df = df[df["Resid 1"] != df["Resid 2"]]

    return df

def update_res_names(df) -> pd.DataFrame:
    """
    Updates odd residue names to more conventional names.
    
    Metal enzyme PDB's are notorious for having unconventional names,
    especially when they are processed with AMBER's MCPB.py utility.

    Parameters
    ----------
    df: pd.DataFrame
        The raw GBSA file read in as a DataFrame.
    
    Returns
    -------
    df: pd.DataFrame
        The GBSA file as a DataFrame with more intuitive residue names.
    
    """

    # Dict containing MCPB residue names and their more conventional pairs
    res_names = {
        "AG2": "ARG",
        "AN1": "ASN",
        "HIE": "HIS",
        "TR1": "TYR",
        "HD1": "HIS",
        "HD2": "HIS",
        "AP1": "ASP",
        "CL1": "CL",
        "SC1": "SUC",
    }

    df.reset_index(inplace=True)
    df = df.replace({"Resname 1": res_names})
    df = df.replace({"Resname 2": res_names})
    df["Resname 2"].replace(res_names)

    df.insert(4, "Residue", df["Resname 2"] + df["Resid 2"].astype(str))

    return df


def get_top_hits_df(df, sub_num, num_hits) -> pd.DataFrame:
    """
    Gets the residues with the greatest energetic contributions.

    The user can specify how many they would like to see.

    Parameters
    ----------
    df: pd.DataFrame
        GBSA DataFrame with the updated residue names.
    sub_num: int
        The index of your substrate.
    Returns
    -------
    df_hits: pd.DataFrame
        The DataFrame sorted only for the residues of interest.
    """
    
    # Get the top largest contributors to ligand interaction energies
    df_hits = df[df["Resid 1"] == sub_num].nsmallest(num_hits, "Total", keep="all")
    df_hits.to_csv("top_hits.csv")

    return df_hits


def figure_formatting() -> None:
    """
    Sets formatting for matplotlib.

    """
    font = {"family": "sans-serif", "weight": "bold", "size": 18}
    plt.rc("font", **font)
    plt.rcParams["svg.fonttype"] = "none"
    plt.rcParams["axes.linewidth"] = 2.5
    plt.rcParams["xtick.major.size"] = 10
    plt.rcParams["xtick.major.width"] = 2.5
    plt.rcParams["ytick.major.size"] = 10
    plt.rcParams["ytick.major.width"] = 2.5
    plt.rcParams["xtick.direction"] = "in"
    plt.rcParams["ytick.direction"] = "in"
    plt.rcParams["mathtext.default"] = "regular"
    plt.legend(bbox_to_anchor=(1.05, 1.0), loc="upper left")


def plot_single_total_gbsa(df, file_name) -> None:
    colors = "#8ecae6"
    ax = df.plot.bar(x="Residue", y="Total", color=colors)
    figure_formatting()
    ax.set_ylabel("GBSA energy score", weight="bold")
    ax.set_xlabel("Residue", weight="bold")
    plt.savefig(file_name, bbox_inches="tight", transparent=True)


def plot_single_all_gbsa(df, file_name) -> None:
    colors = ["#fb8500", "#ffb703", "#023047", "#219ebc", "#8ecae6"]
    ax = df.plot.bar(
        x="Residue", y=["VDW", "Electrostatic", "Polar", "Non-polar"], color=colors
    )
    figure_formatting()
    ax.set_ylabel("GBSA energy score", weight="bold")
    ax.set_xlabel("Residue", weight="bold")
    plt.savefig(file_name, bbox_inches="tight", transparent=True)


def plot_clustered_stacked(dataframes, labels, y_columns, sorted_x_labels):
    H = "//"
    plt.axhline(y=0, color="k", alpha=0.5, linestyle="-", linewidth=3)
    colors = ["#fb8500", "#ffb703", "#023047", "#219ebc", "#8ecae6"]
    number_of_df = len(dataframes)
    number_of_col = len(dataframes[0].columns)
    axe = plt.subplot(111)
    position = -1.15

    for df in dataframes:  # for each data frame
        residue_order = CategoricalDtype(sorted_x_labels, ordered=True)
        df["Residue"] = df["Residue"].astype(residue_order)

        axe = df.sort_values("Residue").plot.bar(
            x="Residue",
            y=y_columns,
            color=colors,
            linewidth=0,
            stacked=True,
            ax=axe,
            legend=False,
            grid=False,
            width=0.3,
            position=position,
        )
        position -= 1
        figure_formatting()

    (
        handles,
        axe_labels,
    ) = axe.get_legend_handles_labels()  # get the handles we want to modify
    for i in range(
        0, number_of_df * number_of_col, number_of_col
    ):  # len(h) = n_col * n_df
        sliced_handles = (
            handles[i : i + number_of_col]
            if i == 0
            else handles[i - 1 : i + number_of_col]
        )
        for j, pa in enumerate(sliced_handles):
            for rect in pa.patches:  # for each index
                rect.set_hatch(H * int(i / number_of_col))  # edited part

    # Add invisible data to add another legend
    n = []
    for i in range(number_of_df):
        n.append(axe.bar(0, 0, color="gray", hatch=H * i))

    l1 = axe.legend(
        handles[:number_of_col], list(axe_labels[: number_of_col - 1]), loc=[1.01, 0.5]
    )

    axe.add_artist(l1)
    axe.set_ylabel("GBSA energy score", weight="bold")
    axe.set_xlabel("Residue", weight="bold")
    axe.set_xticks([tick + 0.65 for tick in axe.get_xticks()])

    return axe


def plot_multi_all_gbsa(df_hits_list, df_list, y_columns, sorted_x_labels) -> None:
    acute_df_hits, obtuse_df_hits, series_columns = prep_multi_gbsa_data(
        df_hits_list, df_list, y_columns
    )
    plot_clustered_stacked(
        [acute_df_hits[series_columns], obtuse_df_hits[series_columns]],
        ["acute", "obtuse"],
        y_columns,
        sorted_x_labels
    )
    plt.savefig("stacked_multi_1.pdf", bbox_inches="tight", transparent=True)


def prep_multi_gbsa_data(df_hits_list, df_list, y_columns):
    acute_df_hits = df_hits_list[0]
    obtuse_df_hits = df_hits_list[1]
    acute_df = df_list[0]
    obtuse_df = df_list[1]
    acute_residues = acute_df_hits["Residue"].tolist()
    obtuse_residues = obtuse_df_hits["Residue"].tolist()
    residues = list(set(acute_residues + obtuse_residues))

    for residue in residues:
        if residue not in acute_residues and residue in obtuse_residues:
            residue_index = obtuse_df_hits.loc[obtuse_df_hits["Residue"] == residue][
                "index"
            ].tolist()[0]
            missing_residue = acute_df.loc[acute_df["index"] == residue_index]
            acute_df_hits = acute_df_hits.append(missing_residue, ignore_index=True)
        elif residue not in obtuse_residues and residue in acute_residues:
            residue_index = acute_df_hits.loc[acute_df_hits["Residue"] == residue][
                "index"
            ].tolist()[0]
            missing_residue = obtuse_df.loc[obtuse_df["index"] == residue_index]
            obtuse_df_hits = obtuse_df_hits.append(missing_residue, ignore_index=True)

    figure_formatting()
    series_columns = y_columns + ["Residue"]

    return acute_df_hits, obtuse_df_hits, series_columns


def plot_multi_total_gbsa(df_hits_list, df_list, y_columns) -> list:
    """
    Create the GBSA plot.

    Parameters
    ----------
    df_hits_list: pd.DataFrame

    df_list: pd.DataFrame

    df_list: list

    y_columns:


    Returns
    -------
    sorted_x_labels: list

    """

    acute_df_hits, obtuse_df_hits, series_columns = prep_multi_gbsa_data(
        df_hits_list, df_list, y_columns
    )
    acute_series = acute_df_hits[series_columns].set_index("Residue").squeeze()
    obtuse_series = obtuse_df_hits[series_columns].set_index("Residue").squeeze()
    figure_formatting()
    new_df = pd.DataFrame({"Acute": acute_series, "Obtuse": obtuse_series})
    new_df = new_df.sort_values(by=["Acute"])
    sorted_x_labels = list(new_df.index)
    ax = new_df.plot.bar(color=["SkyBlue", "IndianRed"])
    ax.set_ylabel("GBSA energy score", weight="bold")
    ax.set_xlabel("Residue", weight="bold")

    plt.savefig("stacked_multi_2.pdf", bbox_inches="tight", transparent=True)

    return sorted_x_labels


def gbsa() -> None:
    '''
    Main GBSA analysis wrapper function.

    '''

    # Welcome user and print some instructions
    print("\n.---------------.")
    print("| GBSA ANALYZER |")
    print(".---------------.\n")
    print("This script will process GBSA output files:")
    print("+ Looks for file24.dat")
    print("+ Will look for more than one GBSA output to compare\n")

    # Get user input
    sub_num = int(input("What is the residue num of your substrate?: ")) - 1
    num_hits = int(input('Show me the top n residues: '))

    file_extension = "*24.dat"
    acute_plot_names = ["acute_total.pdf", "acute_all.pdf"]
    obtuse_plot_names = ["obtuse_total.pdf", "obtuse_all.pdf"]
    plot_file_names = [acute_plot_names, obtuse_plot_names]
    df_list = []
    df_hits_list = []

    # Collect all the GBSA data located in the current directory
    raw_files = glob.glob(file_extension, recursive=True)
    raw_files = sorted(raw_files)

    # Loop through each GBSA file and analyze the results
    for raw, file_name_list in zip(raw_files, plot_file_names):
        df = get_gbsa_df(raw)
        df = update_res_names(df)
        df_hits = get_top_hits_df(df, sub_num, num_hits)
        df_list.append(df)
        df_hits_list.append(df_hits)

        # Generate a plots
        plot_single_total_gbsa(df_hits, file_name_list[0])
        plot_single_all_gbsa(df_hits, file_name_list[1])

    sorted_x_labels = plot_multi_total_gbsa(df_hits_list, df_list, ["Total"])
    plot_multi_all_gbsa(
        df_hits_list,
        df_list,
        ["VDW", "Electrostatic", "Polar", "Non-polar"],
        sorted_x_labels,
    )

# Use to run as a script
if __name__ == "__main__":
    gbsa()
